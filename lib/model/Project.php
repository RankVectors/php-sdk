<?php
/**
 * Project
 *
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * RankVectors API
 *
 * Intelligent internal linking optimization API using AI.   RankVectors helps you automatically discover and implement optimal internal links  across your website to improve SEO performance and user experience.  ## Key Features - **AI-Powered Analysis**: Uses OpenAI embeddings to find optimal linking opportunities - **Smart Crawling**: Automatically crawls and analyzes your website content - **Automated Implementation**: Implement links via webhooks or manual instructions - **Page-Based Plans**: Predictable pricing by number of pages monitored - **Multi-Platform Support**: Works with any CMS or platform via REST API  ## Getting Started 1. Create a project with your website URL 2. Start a crawl to analyze your content 3. Generate AI-powered link suggestions 4. Implement suggestions via API or webhook 5. Track performance and manage page usage and limits  ## Authentication Most API endpoints support authentication using your RankVectors API key. Include your API key in the `Authorization` header: ``` Authorization: Bearer YOUR_API_KEY ```  Get your API key from your RankVectors dashboard: Settings â†’ API Keys  **Note**: Some endpoints (marked in the documentation) support both API key authentication and web session authentication (Stack Auth).  API key authentication is required for SDK usage and external integrations like WordPress plugins.
 *
 * The version of the OpenAPI document: 1.3.1
 * Contact: tj@rankvectors.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.16.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * Project Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class Project implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'Project';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'id' => 'string',
        'name' => 'string',
        'domain' => 'string',
        'user_id' => 'string',
        'prompt' => 'string',
        'search_query' => 'string',
        'sitemap_mode' => 'string',
        'include_subdomains' => 'bool',
        'ignore_query_params' => 'bool',
        'max_discovery_depth' => 'int',
        'exclude_paths' => 'string[]',
        'include_paths' => 'string[]',
        'crawl_entire_domain' => 'bool',
        'allow_external_links' => 'bool',
        'max_pages' => 'int',
        'crawl_delay' => 'int',
        'crawl_max_concurrency' => 'int',
        'only_main_content' => 'bool',
        'custom_headers' => 'array<string,string>',
        'wait_for' => 'int',
        'block_ads' => 'bool',
        'proxy_mode' => 'string',
        'use_reranking' => 'bool',
        'enable_change_tracking' => 'bool',
        'created_at' => '\DateTime',
        'updated_at' => '\DateTime',
        '_count' => '\OpenAPI\Client\Model\ProjectCount'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'id' => null,
        'name' => null,
        'domain' => 'uri',
        'user_id' => null,
        'prompt' => null,
        'search_query' => null,
        'sitemap_mode' => null,
        'include_subdomains' => null,
        'ignore_query_params' => null,
        'max_discovery_depth' => null,
        'exclude_paths' => null,
        'include_paths' => null,
        'crawl_entire_domain' => null,
        'allow_external_links' => null,
        'max_pages' => null,
        'crawl_delay' => null,
        'crawl_max_concurrency' => null,
        'only_main_content' => null,
        'custom_headers' => null,
        'wait_for' => null,
        'block_ads' => null,
        'proxy_mode' => null,
        'use_reranking' => null,
        'enable_change_tracking' => null,
        'created_at' => 'date-time',
        'updated_at' => 'date-time',
        '_count' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'id' => false,
        'name' => false,
        'domain' => false,
        'user_id' => false,
        'prompt' => false,
        'search_query' => false,
        'sitemap_mode' => false,
        'include_subdomains' => false,
        'ignore_query_params' => false,
        'max_discovery_depth' => false,
        'exclude_paths' => false,
        'include_paths' => false,
        'crawl_entire_domain' => false,
        'allow_external_links' => false,
        'max_pages' => false,
        'crawl_delay' => false,
        'crawl_max_concurrency' => false,
        'only_main_content' => false,
        'custom_headers' => false,
        'wait_for' => false,
        'block_ads' => false,
        'proxy_mode' => false,
        'use_reranking' => false,
        'enable_change_tracking' => false,
        'created_at' => false,
        'updated_at' => false,
        '_count' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'id' => 'id',
        'name' => 'name',
        'domain' => 'domain',
        'user_id' => 'userId',
        'prompt' => 'prompt',
        'search_query' => 'searchQuery',
        'sitemap_mode' => 'sitemapMode',
        'include_subdomains' => 'includeSubdomains',
        'ignore_query_params' => 'ignoreQueryParams',
        'max_discovery_depth' => 'maxDiscoveryDepth',
        'exclude_paths' => 'excludePaths',
        'include_paths' => 'includePaths',
        'crawl_entire_domain' => 'crawlEntireDomain',
        'allow_external_links' => 'allowExternalLinks',
        'max_pages' => 'maxPages',
        'crawl_delay' => 'crawlDelay',
        'crawl_max_concurrency' => 'crawlMaxConcurrency',
        'only_main_content' => 'onlyMainContent',
        'custom_headers' => 'customHeaders',
        'wait_for' => 'waitFor',
        'block_ads' => 'blockAds',
        'proxy_mode' => 'proxyMode',
        'use_reranking' => 'useReranking',
        'enable_change_tracking' => 'enableChangeTracking',
        'created_at' => 'createdAt',
        'updated_at' => 'updatedAt',
        '_count' => '_count'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'id' => 'setId',
        'name' => 'setName',
        'domain' => 'setDomain',
        'user_id' => 'setUserId',
        'prompt' => 'setPrompt',
        'search_query' => 'setSearchQuery',
        'sitemap_mode' => 'setSitemapMode',
        'include_subdomains' => 'setIncludeSubdomains',
        'ignore_query_params' => 'setIgnoreQueryParams',
        'max_discovery_depth' => 'setMaxDiscoveryDepth',
        'exclude_paths' => 'setExcludePaths',
        'include_paths' => 'setIncludePaths',
        'crawl_entire_domain' => 'setCrawlEntireDomain',
        'allow_external_links' => 'setAllowExternalLinks',
        'max_pages' => 'setMaxPages',
        'crawl_delay' => 'setCrawlDelay',
        'crawl_max_concurrency' => 'setCrawlMaxConcurrency',
        'only_main_content' => 'setOnlyMainContent',
        'custom_headers' => 'setCustomHeaders',
        'wait_for' => 'setWaitFor',
        'block_ads' => 'setBlockAds',
        'proxy_mode' => 'setProxyMode',
        'use_reranking' => 'setUseReranking',
        'enable_change_tracking' => 'setEnableChangeTracking',
        'created_at' => 'setCreatedAt',
        'updated_at' => 'setUpdatedAt',
        '_count' => 'setCount'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'id' => 'getId',
        'name' => 'getName',
        'domain' => 'getDomain',
        'user_id' => 'getUserId',
        'prompt' => 'getPrompt',
        'search_query' => 'getSearchQuery',
        'sitemap_mode' => 'getSitemapMode',
        'include_subdomains' => 'getIncludeSubdomains',
        'ignore_query_params' => 'getIgnoreQueryParams',
        'max_discovery_depth' => 'getMaxDiscoveryDepth',
        'exclude_paths' => 'getExcludePaths',
        'include_paths' => 'getIncludePaths',
        'crawl_entire_domain' => 'getCrawlEntireDomain',
        'allow_external_links' => 'getAllowExternalLinks',
        'max_pages' => 'getMaxPages',
        'crawl_delay' => 'getCrawlDelay',
        'crawl_max_concurrency' => 'getCrawlMaxConcurrency',
        'only_main_content' => 'getOnlyMainContent',
        'custom_headers' => 'getCustomHeaders',
        'wait_for' => 'getWaitFor',
        'block_ads' => 'getBlockAds',
        'proxy_mode' => 'getProxyMode',
        'use_reranking' => 'getUseReranking',
        'enable_change_tracking' => 'getEnableChangeTracking',
        'created_at' => 'getCreatedAt',
        'updated_at' => 'getUpdatedAt',
        '_count' => 'getCount'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const SITEMAP_MODE__INCLUDE = 'include';
    public const SITEMAP_MODE_EXCLUDE = 'exclude';
    public const SITEMAP_MODE_ONLY = 'only';
    public const PROXY_MODE_AUTO = 'auto';
    public const PROXY_MODE_RESIDENTIAL = 'residential';
    public const PROXY_MODE_DATACENTER = 'datacenter';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSitemapModeAllowableValues()
    {
        return [
            self::SITEMAP_MODE__INCLUDE,
            self::SITEMAP_MODE_EXCLUDE,
            self::SITEMAP_MODE_ONLY,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getProxyModeAllowableValues()
    {
        return [
            self::PROXY_MODE_AUTO,
            self::PROXY_MODE_RESIDENTIAL,
            self::PROXY_MODE_DATACENTER,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('id', $data ?? [], null);
        $this->setIfExists('name', $data ?? [], null);
        $this->setIfExists('domain', $data ?? [], null);
        $this->setIfExists('user_id', $data ?? [], null);
        $this->setIfExists('prompt', $data ?? [], null);
        $this->setIfExists('search_query', $data ?? [], null);
        $this->setIfExists('sitemap_mode', $data ?? [], null);
        $this->setIfExists('include_subdomains', $data ?? [], null);
        $this->setIfExists('ignore_query_params', $data ?? [], null);
        $this->setIfExists('max_discovery_depth', $data ?? [], null);
        $this->setIfExists('exclude_paths', $data ?? [], null);
        $this->setIfExists('include_paths', $data ?? [], null);
        $this->setIfExists('crawl_entire_domain', $data ?? [], null);
        $this->setIfExists('allow_external_links', $data ?? [], null);
        $this->setIfExists('max_pages', $data ?? [], null);
        $this->setIfExists('crawl_delay', $data ?? [], null);
        $this->setIfExists('crawl_max_concurrency', $data ?? [], null);
        $this->setIfExists('only_main_content', $data ?? [], null);
        $this->setIfExists('custom_headers', $data ?? [], null);
        $this->setIfExists('wait_for', $data ?? [], null);
        $this->setIfExists('block_ads', $data ?? [], null);
        $this->setIfExists('proxy_mode', $data ?? [], null);
        $this->setIfExists('use_reranking', $data ?? [], null);
        $this->setIfExists('enable_change_tracking', $data ?? [], null);
        $this->setIfExists('created_at', $data ?? [], null);
        $this->setIfExists('updated_at', $data ?? [], null);
        $this->setIfExists('_count', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['id'] === null) {
            $invalidProperties[] = "'id' can't be null";
        }
        if ($this->container['name'] === null) {
            $invalidProperties[] = "'name' can't be null";
        }
        if ($this->container['domain'] === null) {
            $invalidProperties[] = "'domain' can't be null";
        }
        if ($this->container['user_id'] === null) {
            $invalidProperties[] = "'user_id' can't be null";
        }
        $allowedValues = $this->getSitemapModeAllowableValues();
        if (!is_null($this->container['sitemap_mode']) && !in_array($this->container['sitemap_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'sitemap_mode', must be one of '%s'",
                $this->container['sitemap_mode'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getProxyModeAllowableValues();
        if (!is_null($this->container['proxy_mode']) && !in_array($this->container['proxy_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'proxy_mode', must be one of '%s'",
                $this->container['proxy_mode'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['created_at'] === null) {
            $invalidProperties[] = "'created_at' can't be null";
        }
        if ($this->container['updated_at'] === null) {
            $invalidProperties[] = "'updated_at' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets id
     *
     * @return string
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string $id Unique project identifier
     *
     * @return self
     */
    public function setId($id)
    {
        if (is_null($id)) {
            throw new \InvalidArgumentException('non-nullable id cannot be null');
        }
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name Project name
     *
     * @return self
     */
    public function setName($name)
    {
        if (is_null($name)) {
            throw new \InvalidArgumentException('non-nullable name cannot be null');
        }
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets domain
     *
     * @return string
     */
    public function getDomain()
    {
        return $this->container['domain'];
    }

    /**
     * Sets domain
     *
     * @param string $domain Website domain URL
     *
     * @return self
     */
    public function setDomain($domain)
    {
        if (is_null($domain)) {
            throw new \InvalidArgumentException('non-nullable domain cannot be null');
        }
        $this->container['domain'] = $domain;

        return $this;
    }

    /**
     * Gets user_id
     *
     * @return string
     */
    public function getUserId()
    {
        return $this->container['user_id'];
    }

    /**
     * Sets user_id
     *
     * @param string $user_id User who owns the project
     *
     * @return self
     */
    public function setUserId($user_id)
    {
        if (is_null($user_id)) {
            throw new \InvalidArgumentException('non-nullable user_id cannot be null');
        }
        $this->container['user_id'] = $user_id;

        return $this;
    }

    /**
     * Gets prompt
     *
     * @return string|null
     */
    public function getPrompt()
    {
        return $this->container['prompt'];
    }

    /**
     * Sets prompt
     *
     * @param string|null $prompt Natural language prompt for crawling
     *
     * @return self
     */
    public function setPrompt($prompt)
    {
        if (is_null($prompt)) {
            throw new \InvalidArgumentException('non-nullable prompt cannot be null');
        }
        $this->container['prompt'] = $prompt;

        return $this;
    }

    /**
     * Gets search_query
     *
     * @return string|null
     */
    public function getSearchQuery()
    {
        return $this->container['search_query'];
    }

    /**
     * Sets search_query
     *
     * @param string|null $search_query Search query for targeted crawling
     *
     * @return self
     */
    public function setSearchQuery($search_query)
    {
        if (is_null($search_query)) {
            throw new \InvalidArgumentException('non-nullable search_query cannot be null');
        }
        $this->container['search_query'] = $search_query;

        return $this;
    }

    /**
     * Gets sitemap_mode
     *
     * @return string|null
     */
    public function getSitemapMode()
    {
        return $this->container['sitemap_mode'];
    }

    /**
     * Sets sitemap_mode
     *
     * @param string|null $sitemap_mode How to handle sitemaps
     *
     * @return self
     */
    public function setSitemapMode($sitemap_mode)
    {
        if (is_null($sitemap_mode)) {
            throw new \InvalidArgumentException('non-nullable sitemap_mode cannot be null');
        }
        $allowedValues = $this->getSitemapModeAllowableValues();
        if (!in_array($sitemap_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'sitemap_mode', must be one of '%s'",
                    $sitemap_mode,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['sitemap_mode'] = $sitemap_mode;

        return $this;
    }

    /**
     * Gets include_subdomains
     *
     * @return bool|null
     */
    public function getIncludeSubdomains()
    {
        return $this->container['include_subdomains'];
    }

    /**
     * Sets include_subdomains
     *
     * @param bool|null $include_subdomains Whether to include subdomains
     *
     * @return self
     */
    public function setIncludeSubdomains($include_subdomains)
    {
        if (is_null($include_subdomains)) {
            throw new \InvalidArgumentException('non-nullable include_subdomains cannot be null');
        }
        $this->container['include_subdomains'] = $include_subdomains;

        return $this;
    }

    /**
     * Gets ignore_query_params
     *
     * @return bool|null
     */
    public function getIgnoreQueryParams()
    {
        return $this->container['ignore_query_params'];
    }

    /**
     * Sets ignore_query_params
     *
     * @param bool|null $ignore_query_params Whether to ignore URL query parameters
     *
     * @return self
     */
    public function setIgnoreQueryParams($ignore_query_params)
    {
        if (is_null($ignore_query_params)) {
            throw new \InvalidArgumentException('non-nullable ignore_query_params cannot be null');
        }
        $this->container['ignore_query_params'] = $ignore_query_params;

        return $this;
    }

    /**
     * Gets max_discovery_depth
     *
     * @return int|null
     */
    public function getMaxDiscoveryDepth()
    {
        return $this->container['max_discovery_depth'];
    }

    /**
     * Sets max_discovery_depth
     *
     * @param int|null $max_discovery_depth Maximum crawl depth
     *
     * @return self
     */
    public function setMaxDiscoveryDepth($max_discovery_depth)
    {
        if (is_null($max_discovery_depth)) {
            throw new \InvalidArgumentException('non-nullable max_discovery_depth cannot be null');
        }
        $this->container['max_discovery_depth'] = $max_discovery_depth;

        return $this;
    }

    /**
     * Gets exclude_paths
     *
     * @return string[]|null
     */
    public function getExcludePaths()
    {
        return $this->container['exclude_paths'];
    }

    /**
     * Sets exclude_paths
     *
     * @param string[]|null $exclude_paths Paths to exclude from crawling
     *
     * @return self
     */
    public function setExcludePaths($exclude_paths)
    {
        if (is_null($exclude_paths)) {
            throw new \InvalidArgumentException('non-nullable exclude_paths cannot be null');
        }
        $this->container['exclude_paths'] = $exclude_paths;

        return $this;
    }

    /**
     * Gets include_paths
     *
     * @return string[]|null
     */
    public function getIncludePaths()
    {
        return $this->container['include_paths'];
    }

    /**
     * Sets include_paths
     *
     * @param string[]|null $include_paths Specific paths to include
     *
     * @return self
     */
    public function setIncludePaths($include_paths)
    {
        if (is_null($include_paths)) {
            throw new \InvalidArgumentException('non-nullable include_paths cannot be null');
        }
        $this->container['include_paths'] = $include_paths;

        return $this;
    }

    /**
     * Gets crawl_entire_domain
     *
     * @return bool|null
     */
    public function getCrawlEntireDomain()
    {
        return $this->container['crawl_entire_domain'];
    }

    /**
     * Sets crawl_entire_domain
     *
     * @param bool|null $crawl_entire_domain Whether to crawl the entire domain
     *
     * @return self
     */
    public function setCrawlEntireDomain($crawl_entire_domain)
    {
        if (is_null($crawl_entire_domain)) {
            throw new \InvalidArgumentException('non-nullable crawl_entire_domain cannot be null');
        }
        $this->container['crawl_entire_domain'] = $crawl_entire_domain;

        return $this;
    }

    /**
     * Gets allow_external_links
     *
     * @return bool|null
     */
    public function getAllowExternalLinks()
    {
        return $this->container['allow_external_links'];
    }

    /**
     * Sets allow_external_links
     *
     * @param bool|null $allow_external_links Whether to allow external links
     *
     * @return self
     */
    public function setAllowExternalLinks($allow_external_links)
    {
        if (is_null($allow_external_links)) {
            throw new \InvalidArgumentException('non-nullable allow_external_links cannot be null');
        }
        $this->container['allow_external_links'] = $allow_external_links;

        return $this;
    }

    /**
     * Gets max_pages
     *
     * @return int|null
     */
    public function getMaxPages()
    {
        return $this->container['max_pages'];
    }

    /**
     * Sets max_pages
     *
     * @param int|null $max_pages Maximum number of pages to crawl
     *
     * @return self
     */
    public function setMaxPages($max_pages)
    {
        if (is_null($max_pages)) {
            throw new \InvalidArgumentException('non-nullable max_pages cannot be null');
        }
        $this->container['max_pages'] = $max_pages;

        return $this;
    }

    /**
     * Gets crawl_delay
     *
     * @return int|null
     */
    public function getCrawlDelay()
    {
        return $this->container['crawl_delay'];
    }

    /**
     * Sets crawl_delay
     *
     * @param int|null $crawl_delay Delay between crawl requests (ms)
     *
     * @return self
     */
    public function setCrawlDelay($crawl_delay)
    {
        if (is_null($crawl_delay)) {
            throw new \InvalidArgumentException('non-nullable crawl_delay cannot be null');
        }
        $this->container['crawl_delay'] = $crawl_delay;

        return $this;
    }

    /**
     * Gets crawl_max_concurrency
     *
     * @return int|null
     */
    public function getCrawlMaxConcurrency()
    {
        return $this->container['crawl_max_concurrency'];
    }

    /**
     * Sets crawl_max_concurrency
     *
     * @param int|null $crawl_max_concurrency Maximum concurrent crawl requests
     *
     * @return self
     */
    public function setCrawlMaxConcurrency($crawl_max_concurrency)
    {
        if (is_null($crawl_max_concurrency)) {
            throw new \InvalidArgumentException('non-nullable crawl_max_concurrency cannot be null');
        }
        $this->container['crawl_max_concurrency'] = $crawl_max_concurrency;

        return $this;
    }

    /**
     * Gets only_main_content
     *
     * @return bool|null
     */
    public function getOnlyMainContent()
    {
        return $this->container['only_main_content'];
    }

    /**
     * Sets only_main_content
     *
     * @param bool|null $only_main_content Whether to extract only main content
     *
     * @return self
     */
    public function setOnlyMainContent($only_main_content)
    {
        if (is_null($only_main_content)) {
            throw new \InvalidArgumentException('non-nullable only_main_content cannot be null');
        }
        $this->container['only_main_content'] = $only_main_content;

        return $this;
    }

    /**
     * Gets custom_headers
     *
     * @return array<string,string>|null
     */
    public function getCustomHeaders()
    {
        return $this->container['custom_headers'];
    }

    /**
     * Sets custom_headers
     *
     * @param array<string,string>|null $custom_headers Custom headers for crawling
     *
     * @return self
     */
    public function setCustomHeaders($custom_headers)
    {
        if (is_null($custom_headers)) {
            throw new \InvalidArgumentException('non-nullable custom_headers cannot be null');
        }
        $this->container['custom_headers'] = $custom_headers;

        return $this;
    }

    /**
     * Gets wait_for
     *
     * @return int|null
     */
    public function getWaitFor()
    {
        return $this->container['wait_for'];
    }

    /**
     * Sets wait_for
     *
     * @param int|null $wait_for Wait time for page load (ms)
     *
     * @return self
     */
    public function setWaitFor($wait_for)
    {
        if (is_null($wait_for)) {
            throw new \InvalidArgumentException('non-nullable wait_for cannot be null');
        }
        $this->container['wait_for'] = $wait_for;

        return $this;
    }

    /**
     * Gets block_ads
     *
     * @return bool|null
     */
    public function getBlockAds()
    {
        return $this->container['block_ads'];
    }

    /**
     * Sets block_ads
     *
     * @param bool|null $block_ads Whether to block ads
     *
     * @return self
     */
    public function setBlockAds($block_ads)
    {
        if (is_null($block_ads)) {
            throw new \InvalidArgumentException('non-nullable block_ads cannot be null');
        }
        $this->container['block_ads'] = $block_ads;

        return $this;
    }

    /**
     * Gets proxy_mode
     *
     * @return string|null
     */
    public function getProxyMode()
    {
        return $this->container['proxy_mode'];
    }

    /**
     * Sets proxy_mode
     *
     * @param string|null $proxy_mode Proxy mode for crawling
     *
     * @return self
     */
    public function setProxyMode($proxy_mode)
    {
        if (is_null($proxy_mode)) {
            throw new \InvalidArgumentException('non-nullable proxy_mode cannot be null');
        }
        $allowedValues = $this->getProxyModeAllowableValues();
        if (!in_array($proxy_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'proxy_mode', must be one of '%s'",
                    $proxy_mode,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['proxy_mode'] = $proxy_mode;

        return $this;
    }

    /**
     * Gets use_reranking
     *
     * @return bool|null
     */
    public function getUseReranking()
    {
        return $this->container['use_reranking'];
    }

    /**
     * Sets use_reranking
     *
     * @param bool|null $use_reranking Whether to use AI reranking
     *
     * @return self
     */
    public function setUseReranking($use_reranking)
    {
        if (is_null($use_reranking)) {
            throw new \InvalidArgumentException('non-nullable use_reranking cannot be null');
        }
        $this->container['use_reranking'] = $use_reranking;

        return $this;
    }

    /**
     * Gets enable_change_tracking
     *
     * @return bool|null
     */
    public function getEnableChangeTracking()
    {
        return $this->container['enable_change_tracking'];
    }

    /**
     * Sets enable_change_tracking
     *
     * @param bool|null $enable_change_tracking Whether to enable change tracking
     *
     * @return self
     */
    public function setEnableChangeTracking($enable_change_tracking)
    {
        if (is_null($enable_change_tracking)) {
            throw new \InvalidArgumentException('non-nullable enable_change_tracking cannot be null');
        }
        $this->container['enable_change_tracking'] = $enable_change_tracking;

        return $this;
    }

    /**
     * Gets created_at
     *
     * @return \DateTime
     */
    public function getCreatedAt()
    {
        return $this->container['created_at'];
    }

    /**
     * Sets created_at
     *
     * @param \DateTime $created_at Project creation timestamp
     *
     * @return self
     */
    public function setCreatedAt($created_at)
    {
        if (is_null($created_at)) {
            throw new \InvalidArgumentException('non-nullable created_at cannot be null');
        }
        $this->container['created_at'] = $created_at;

        return $this;
    }

    /**
     * Gets updated_at
     *
     * @return \DateTime
     */
    public function getUpdatedAt()
    {
        return $this->container['updated_at'];
    }

    /**
     * Sets updated_at
     *
     * @param \DateTime $updated_at Last update timestamp
     *
     * @return self
     */
    public function setUpdatedAt($updated_at)
    {
        if (is_null($updated_at)) {
            throw new \InvalidArgumentException('non-nullable updated_at cannot be null');
        }
        $this->container['updated_at'] = $updated_at;

        return $this;
    }

    /**
     * Gets _count
     *
     * @return \OpenAPI\Client\Model\ProjectCount|null
     */
    public function getCount()
    {
        return $this->container['_count'];
    }

    /**
     * Sets _count
     *
     * @param \OpenAPI\Client\Model\ProjectCount|null $_count _count
     *
     * @return self
     */
    public function setCount($_count)
    {
        if (is_null($_count)) {
            throw new \InvalidArgumentException('non-nullable _count cannot be null');
        }
        $this->container['_count'] = $_count;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer|string $offset Offset
     *
     * @return boolean
     */
    public function offsetExists(mixed $offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer|string $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet(mixed $offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer|string $offset Offset
     *
     * @return void
     */
    public function offsetUnset(mixed $offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


